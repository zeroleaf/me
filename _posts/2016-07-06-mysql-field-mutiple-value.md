---
layout: post
title:  "Mysql 多值字段存储"
date:   2016-07-06 14:16:32
categories: mysql
---

今天碰到一个问题, 需要往一个商品里面添加多个渠道, 照一般的做法是建立一张关联表, 
然后通过外键关联渠道即可. 但由于工程里面添加表并不是很方便, 同时关联表也会使得
查询变得复杂且 '低效', 因此并不符合当前实际. 想到只是 2, 3 个渠道, 是否有办法通过
**位操作** 来实现, Google 了一番发现是可以的.

首先, 以二进制位来表示一个具体的渠道, 如:

- 1 (对应二进制 0001) 表示 渠道 A
- 2 (对应二进制 0010) 表示 渠道 B
- 4 (对应二进制 0100) 表示 渠道 C

这样字段中存储的即是这些渠道对应的数字的和. 如包含有渠道 A, C, 则存储的值为 1 + 4 = 5.

而之后查询是否包含有某个渠道也可通过如下的语句实现:

~~~ sql
-- 查询包含有 渠道 B 的数据

-- 异或
SELECT * FROM `table_name` WHERE (channel ^ 2) < channel;

-- 按位与
SELECT * FROM `table_name` WHERE (channel & 2) = 2;
~~~

按位与的实现应该是相对容易理解的, 异或的原理是 **0 ^ 0 = 0**, **1 ^ 0 = 1**, **1 ^ 1 = 0**,
可见, 不管 0 或 1 异或 0 都不变. 因此, 我们按位异或一个只有一位为 1 的数, 如果对应位上为 1,
则该位的异或结果为 0, 小于原来原值(即我们需要的结果); 如果对应位上为 0, 则异或的结果为 1,
大于原值. 

如果要确定 channel 中都包含有哪些渠道, 可以对没一位进行按位与, 结果不为 0 即说明包含有该渠道.

## 性能

基于该方法的实现性能还是非常高的, 本机测试 按位异或 与 按位与 的实现在单张表的情况下性能差不多.
但 EXPLAIN 的结果为: 异或中的 *filtered* 为 **33.33** 而 按位与 中的为 **100.00**, 
filtered 的值具体说明啥现在还不是很了解? 

但不管如何, 都是要比基于关联表的实现要快相当多!

## 不足

由于每个标识都要占一位, 而 mysql 的 int 为 4 字节, 即最多只能存储 32 个标识,
因此对于标识量很多的数据, 这种实现方式不一定适合. 

## 参考

- <https://segmentfault.com/a/1190000002965124>

